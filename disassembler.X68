*-----------------------------------------------------------
* Title      : DASM
* Written by : Duncan Spani, Robin Seo, Jaeha Choi, Nicolas Feuchster
* Date       : Spring 2021
* Description: Disassembler Project, CSS 422
*-----------------------------------------------------------
    ORG    $1000   
START:
    BSR     INPUT_START_ADDRESS
    MOVE.L  (START_ADDRESS), A6
    BSR     INPUT_END_ADDRESS                
    BRA     MAIN    ; START DISASSEMBLY


**--------GET INSTRUCTION FROM USER---------**
GET_INSTRUCTION:        ; GET INSTRUCTION FROM USER
    LEA     INSTRUCTION_PROMPT, A1  ; LOAD PROMPT INTO A1
    MOVE.B  #14, D0                 ; LOAD 14 INTO D0
    TRAP    #15                     ; TRAP TASK 14, DISPLAY NULL TERM STRING
    
    LEA     ASCII_INSTRUCTION, A1   ; LOAD STARTING ADDRESS OF CURRENT INSTRUCTION
    MOVE.B  #2, D0
    TRAP    #15                     ; TRAP TASK 2, READ STRING FROM USER
    MOVE.W  D1, INSTRUCTION_LENGTH  ; MOVE STRING LENGTH TO D5

    RTS                             ; RETURN TO STACK ADDRESS
**--------------CONVERSION ASCII TO HEX LOGIC------------**
;-------------------------------------
; ** CONVERT ASCII INPUT STRING TO HEX
; ASCII NUMS 0-9 = 48-57 -- sub.b 48, val
; ASCII LETTERS A-F = 65-70 -- sub.b 55, val
; ** ARGUMENTS:
; A1: SOURCE ADDRESS
;   ADDRESS OF A DATA STORAGE THAT STORES NULL OR $FF TERMINATED ASCII VALUE
; A2: DESTINATION ADDRESS
;   ADDRESS OF A DATA STORAGE THAT STORES HEX VALUE OF THE SOURCE ASCII VALUE
; ** RETURNS:
; A2:
;   UPDATE VALUE OF DESTINATION ADDRESS DATA STORAGE TO STORE HEX VALUE OF THE PROVIDED ASCII CHAR 
;------------------------------------
ASCII_TO_HEX:
    MOVE.B  (A1)+, D1                ; MOVE FIRST BYTE TO D1
    MOVE.B  (A1)+, D2                ; MOVE NEXT BYTE TO D2
    MOVE.B  #0, D4                   ; SET COUNTER TO 0
    ;BSR     CONVERSION_LOOP
    BRA     CONVERSION_LOOP


CONVERSION_LOOP:
    CMP.B   #0, D1 
    BEQ     END_INSTRUCTION           ; BRANCH TO END ON NULL
    CMP.B   #$FF, D1
    BEQ     END_INSTRUCTION           ; END IF BYTE FF (NON-NULL TERMINATED)
    CMP.B   #47, D1
    BLT     INPUT_ERROR               ; ERROR IF VALUE LESS THAN 47
    CMP.B   #71, D1
    BGT     INPUT_ERROR               ; ERROR IF VALUES GREATER THAN 71
    CMP.B   #57, D1
    BLE     NUMBER                    ; NUMBER IF VALUE BETWEEN 48 AND 57
    CMP.B   #65, D1
    BGE     LETTER                    ; LETTER IF VALUE BETWEEN 65 AND 70
    ;RTS 
    BRA     INPUT_ERROR
    
COMBINE_BYTE:
    MOVE.B  #0, D4                  ; CLEAR D4
    MOVE.B  D5, (A2)                ; MOVE D5 INTO INSTRUCTION MEMORY
    MOVE.B  #0, D5                  ; CLEAR D5
    ADD.L   #1, A2                  ; INCREMENT A2 ADDRESS
    MOVE.B  (A1)+, D2               ; GRAB NEW VALUE FROM A1, PLACE IN D2
    BRA CONVERSION_LOOP

END_INSTRUCTION:
    RTS                             ; RETURN TO MAIN

NUMBER:
    SUB.B   #48, D1                 ; CONVERT ASCII NUM TO HEX VALUE
    LSL.B   #4, D5                  ; LEFT SHIFT D5
    ADD.B   D1, D5                  ; MOVE D1 INTO D5
    MOVE.B  D2, D1                  ; QUEUE D2 INTO D1 FOR CONVERSION
    ADD.B   #1, D4                  ; INCREMENT COUNTER IN D4
    CMP.B   #2, D4                  
    BEQ     COMBINE_BYTE            ; BRANCH IF COUNTER IS 2
    MOVE.B  (A1)+, D2               ; DEREFERENCE NEW VALUE AND PLACE INTO D2
    BRA     CONVERSION_LOOP
    
LETTER:
    SUB.B   #55, D1                 ; CONVERT ASCII NUM TO HEX VALUE
    LSL.B   #4, D5                  ; LEFT SHIFT D5
    ADD.B   D1, D5                  ; MOVE D1 INTO D5
    MOVE.B  D2, D1                  ; QUEUE D2 INTO D1 FOR CONVERSION
    ADD.B   #1, D4                  ; INCREMENT COUNTER IN D4
    CMP.B   #2, D4                  
    BEQ     COMBINE_BYTE            ; BRANCH IF COUNTER IS 2
    MOVE.B  (A1)+, D2               ; DEREFERENCE NEW VALUE AND PLACE INTO D2
    BRA     CONVERSION_LOOP
**----------END CONVERSION ASCII TO HEX LOGIC------------**
INPUT_ERROR:
    LEA     ERROR, A1
    MOVE.B  #13, D0
    TRAP    #15                     ; PRINT ERROR MESSAGE ON INSTRUCTION ERROR
    BSR     CLEAR_INSTRUCTION_MEMORY
    BRA     MAIN

**--------------GET ADDRESSING----------------**
INPUT_START_ADDRESS:
    LEA     GET_START_ADDRESS, A1
    MOVE.B  #14, D0
    TRAP    #15                     ; PRINT COMMAND FOR STARTING ADDRESS
    MOVE.B  #2, D0                  ; READ A NUMBER FROM THE KEYBOARD
    TRAP    #15
    LEA     START_ADDRESS, A2
    BSR     ASCII_TO_HEX            ; CONVERT 8 DIGIT ASCII ADDRESS TO HEX
    RTS
 
INPUT_END_ADDRESS:
    LEA     GET_END_ADDRESS, A1
    MOVE.B  #14, D0
    TRAP    #15                     ; PRINT COMMAND FOR STARTING ADDRESS
    MOVE.B  #2, D0                  ; READ A NUMBER FROM THE KEYBOARD
    TRAP    #15
    LEA     END_ADDRESS , A2
    BSR     ASCII_TO_HEX            ; CONVERT 8 DIGIT ASCII ADDRESS TO HEX
    RTS
**------------END GET ADDRESSING------------**
**--------------GET NYBBLE----------------**
;-------------------------------------
; ** GET FIRST NYBBLE
; ** ARGUMENTS:
; D1: SOURCE REGISTER
;   D1 STORES INSTRUCTION
; ** RETURNS:
; D1:
;   D1 SAVES TO FIRST_FOUR_NYBBLE
;------------------------------------

**------------------START OF APIs----------------** 
GET_FIRST_NYBBLE:           ; RETURN FIRST FOUR BITS 

    MOVE.W  #$F000, D2  ; mask = $F000
    AND.W   D2, D1
    
    LSR.W   #8, D1  
    LSR.W   #4, D1

    MOVE.B  D1, FIRST_FOUR_NYBBLE   
;-------------------------------------
; ** MATCH INSTRUCTION AND BRANCHING TO THE SPECIFIDE INSTRUCTION BRANCH
; LOOKING FOR CONSTANT X BITS TO MATCH WITH INSTRUCTION OP CODE
; X IS THE NUMBER OF THE BITS THAT ARE DISTINCT PATTERN OF THE INSTRUCTION OP CODE 
; ALSO, IT DOESN'T NEED TO BE CONSECUTIVE 
;------------------------------------
MATCH_INSTRUCTION:  ;match instruction and branching to the specifide instruction branch       
    MOVE.L  D7, D5
    CMP.W   #$4E75, D5              ; COMPARE TO CONSTANT RTS OP CODE
    BEQ     RTS
    
    MOVE.L  D7, D5          
    CMP.W   #$4E71, D5              ; COMPARE TO CONSTANT NOP OP CODE
    BEQ     NOP
    
    MOVE.L  D7, D5
    AND.W   #%1100000000000000, D5  ; COMPARE TO CONSTANT 2 BITS MOVE OP CODE 
    CMP.W   #$0000, D5
    BEQ     MOVE
    
    MOVE.L  D7, D5
    AND.W   #%1111111111000000, D5  ; COMPARE TO CONSTANT 10 BITS JSR OP CODE 
    CMP.W   #%0100111010000000, D5
    BEQ     JSR
    
    MOVE.L  D7, D5
    AND.W   #%1111101110000000, D5  ; COMPARE TO CONSTANT 8 BITS MOVEM OP CODE (DIRECTION AND SIZE CAN BE VARY)
    CMP.W   #%0100100010000000, D5
    BEQ     MOVEM
    
    MOVE.L  D7, D5
    AND.W   #%1111000111000000, D5  ; COMPARE TO CONSTANT 7 BITS LEA OP CODE (REGISTER CAN BE VARY)
    CMP.W   #%0100000111000000, D5
    BEQ     LEA
    
    MOVE.L  D7, D5
    AND.W   #%1111111100000000, D5  ; COMPARE TO CONSTANT 8 BITS NOT OP CODE
    CMP.W   #%0100011000000000, D5
    BEQ     NOT
    
    MOVE.L  D7, D5
    AND.W   #%1111111100000000, D5  ; COMPARE TO CONSTANT 8 BITS BLT OP CODE
    CMP.W   #%0110110100000000, D5
    BEQ     BLT
    
    MOVE.L  D7, D5
    AND.W   #%1111111100000000, D5  ; COMPARE TO CONSTANT 8 BITS BGE OP CODE
    CMP.W   #%0110110000000000, D5
    BEQ     BGE
    
    MOVE.L  D7, D5
    AND.W   #%1111111100000000, D5  ; COMPARE TO CONSTANT 8 BITS BEQ OP CODE
    CMP.W   #%0110011100000000, D5
    BEQ     BEQ
    
    MOVE.L  D7, D5
    AND.W   #%1111111100000000, D5  ; COMPARE TO CONSTANT 8 BITS BRA OP CODE
    CMP.W   #%0110000000000000, D5
    BEQ     BRA
    
    MOVE.L  D7, D5
    AND.W   #%1111000000000000, D5  ; COMPARE TO CONSTANT 4 BITS DIVU OP CODE (REGISTER CAN BE VARY)
    CMP.W   #%1000000000000000, D5
    BEQ     DIVU
    
    MOVE.L  D7, D5
    AND.W   #%1111000000000000, D5  ; COMPARE TO CONSTANT 4 BITS SUB OP CODE (REGISTER CAN BE VARY)
    CMP.W   #%1001000000000000, D5
    BEQ     SUB
    
    MOVE.L  D7, D5
    AND.W   #%1111000111000000, D5  ; COMPARE TO CONSTANT 7 BITS MULS OP CODE (RESGITER CAN BE VARY)
    CMP.W   #%1100000111000000, D5
    BEQ     MULS
    
    MOVE.L  D7, D5
    AND.W   #%1111000000000000, D5  ; COMPARE TO CONSTANT 4 BITS AND OP CODE (REGISTER CAN BE VARY)
    CMP.W   #%1100000000000000, D5
    BEQ     AND
    
    MOVE.L  D7, D5
    AND.W   #%1111000000000000, D5  ; COMPARE TO CONSTANT 4 BITS ADD OP CODE (REGISTER CAN BE VARY)
    CMP.W   #%1101000000000000, D5
    BEQ     ADD
    
    MOVE.L  D7, D5
    AND.W   #%1111111011000000, D5  ; COMPARE TO CONSTANT 9 BITS LSD_IMMEDIATE OP CODE (DIRECTION CAN BE VARY)
    CMP.W   #%1110001011000000, D5
    BEQ     LSD_IMMEDIATE
    
    MOVE.L  D7, D5
    AND.W   #%1111000000011000, D5  ; COMPARE TO CONSTANT 6 BITS LSD_REGISTER OP CODE (COUNT, DIRECTION, SIZE,
                                    ; IMMEDIATE/REGISTER SHIFT COUNT, REGISTER CAN BE VARY)
    CMP.W   #%1110000000001000, D5
    BEQ     LSD_REGISTER
    
    MOVE.L  D7, D5
    AND.W   #%1111111011000000, D5  ; COMPARE TO CONSTANT 9 BITS ASD_IMMEDIATE OP CODE (DIRECTION CAN BE VARY)
    CMP.W   #%1110000011000000, D5
    BEQ     ASD_IMMEDIATE
    
    MOVE.L  D7, D5
    AND.W   #%1111000000011000, D5  ; COMPARE TO CONSTANT 6 BITS ASD_REGISTER OP CODE (COUNT, DIRECTION, SIZE,
                                    ; IMMEDIATE/REGISTER SHIFT COUNT, REGISTER CAN BE VARY)
    CMP.W   #%1110000000000000, D5
    BEQ     ASD_REGISTER
    
    ;BRANCH NO MATTER WHAT TO INVALID IF INSTRUCTION DOES NOT MATCH   
    BRA     INVALID
      

**--------------GET BITS----------------**
;-------------------------------------
; ** GET N NUMBER OF BITS BASED X STARTING LOCATION
; ** REPLICATION OF "INT GETBITS(SHORT INSTRUCTION, INT START, INT END)"
; ** ARGUMENTS:
; D1: SOURCE INSTRCUTION
;   D1 STORES THE BASE WORD INSTRUCTION
; D2: STARTING LOCATION
;   X STARTING LOCATION FROM LEFT TO RIGHT OF BASE INSTRUCTION STARTING FROM 0
; D3: NUMBER OF BITS TO GET
;   N NUMBER OF BITS TO GET STARTING FROM D2 STARTING LOCATION STARTING FROM 1
; ** RETURNS:
; D1:
;   D1 CONTAINS ONLY THE BITS STARTING FROM X SHIFTED ALL THE WAY TO THE RIGHT
;------------------------------------
GET_BITS: 
	MOVE.W #16, D4                  ; MOVE WORD SIZE INTO D4
	SUB.W D3, D4                    ; GET NUM OF BITS AFTER IMPORTANT BITS
	
	MOVE.W D2, D5                   ; MOVE STARTING LOCATION TO D5
	MOVE.W D3, D6                   ; MOVE NUMBER OF BITS TO D6
	LEFT_SHIFT:
	CMP.W #0, D2                    ; COMPARE 0 TO STARTING LOCATION
	BEQ RIGHT_SHIFT                 ; BRANCH TO RIGHT SHIFT IS LEFT_SHIFT
	SUB.W #1, D2                    ; DECREMENT COUNTER BY 1
	LSL.W #1, D1                    ; LEFT SHIFT INSTRUCTION BY 1

	BRA LEFT_SHIFT                  ; RESTART LEFT SHIFT
	RIGHT_SHIFT:
	CMP.W #0, D4                    ; COMPARE 0 TO D4 REGISTER
	BEQ GET_BITS_END                ; IF 0 END BIT SHIFT
	SUB.W #1, D4                    ; DECREMENT D4 COUNTER BY 1
	LSR.W #1, D1                    ; RIGHT SHIFT INSTRUCTION BY 1
	BRA RIGHT_SHIFT                 ; RESTART RIGHT SHIFT
    GET_BITS_END:
    RTS                             ; HELPER FUNCTION
**------------------END OF APIs----------------**  


**------------------BEGIN MAIN LOOP----------------**  
MAIN:                               ; MAIN LOOP    

    ;BSR     GET_INSTRUCTION         ; RETURNS ASCII INSTRUCTION STARTING AT ASCII_INSTRUCTION ADDRESS
    ;LEA     ASCII_INSTRUCTION, A1   ; LOAD START OF CURRENT INSTRUCTION INTO A1
    ;LEA     INSTRUCTION, A2         ; LOAD DESTINATION 
    ;BSR     ASCII_TO_HEX            ; RETURNS INSTRUCTION AT INSTRUCTION ADDRESS
    ;LEA     INSTRUCTION, A1
    MOVE.L  (END_ADDRESS), A5
    CMP.L   A5, A6
    BGE     END_DISASSEMBLY         ; END IF CURRENT ADDRESS GREATER OR EQUAL TO END ADDRESS
    MOVE.W  (A6)+, D7               ; DEREFERENCE WORD INSTRUCTION FROM POINTER TO CURRENT INSTRUCTION (A6)
    CMP.W   #$FFFF, D7
    BEQ     END_DISASSEMBLY         ; END IF INSTRUCTION = #$FFFF
    BSR     MATCH_INSTRUCTION
    BSR     CLEAR_INSTRUCTION_MEMORY       ; CLEAR MEMORY OF INSTRUCTION
      
    BRA     MAIN                    ; RESTART LOOP
    SIMHALT
**------------------END MAIN LOOP----------------**  
END_DISASSEMBLY:
    SIMHALT

CLEAR_INSTRUCTION_MEMORY:           ; CLEAR ALL PREVIOUSLY USED MEMORY
    LEA     INSTRUCTION, A1         
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.B  #$FF, SIZE
    MOVE.B  #$FF, SIZE_TYPE
    MOVE.B  #$FF, FIRST_FOUR_NYBBLE
    MOVE.B  #$FF, DESTINATION_MODE
    MOVE.B  #$FF, DESTINATION_XN
    MOVE.B  #$FF, SOURCE_MODE
    MOVE.B  #$FF, SOURCE_XN
    MOVE.B  #$FF, DIRECTION
    MOVE.B  #$FF, ROTATION
    MOVE.B  #$FF, DISPLACEMENT
    LEA     ASCII_INSTRUCTION, A1
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    MOVE.W  #$0000, (A1)+
    CLR.L   D0
    CLR.L   D1
    CLR.L   D2
    CLR.L   D3
    CLR.L   D4
    CLR.L   D5
    CLR.L   D6
    CLR.L   D7
    BRA     MAIN

**-----------BEGIN INSTRUCTION DISASSEMBLY----------**
; ** FOR THE FOLLOWING, THE INSTRUCTION MUST BE LOADED
; ** IN D7 FOR REMAINDER OF INSTRUCTION DECOMPOSITION
RTS:
    LEA     OPC_RTS, A1
    MOVE.B  #14, D0
    TRAP    #15                     ; PRINT RTS OP CODE
    BSR     PRINT_NEWLINE
    BSR     CLEAR_INSTRUCTION_MEMORY
    BRA     MAIN
    
NOP:
    LEA     OPC_NOP, A1
    MOVE.B  #14, D0
    TRAP    #15                     ; PRINT NOP OP CODE
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

MOVE:
    ** GET SIZE 3**
    MOVE.B  #3, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #2, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET DESTINATION Xn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET DESTINATION MODE **
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_MODE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN

    ** PRINT INSTRUCTION **
    LEA     OPC_MOVE, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE3
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    BSR     GET_DEST_MODE
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    
JSR:
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_JSR, A1
    BSR     PRINT_OPCODE
    BSR     GET_SOURCE_MODE
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

MOVEM:                                                          
    ** GET DIRECTION **
    ** REGISTER TO MEMORY (0) OR MEMORY TO REGISTER (1)**
    MOVE.W  D7, D1
    MOVE.B  #5, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 2**
    MOVE.B  #2, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #9, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_MOVEM, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE2
    BSR     MOVEM_SUBR
    END_LIST_MASK:
    BSR     PRINT_COMMA
    BSR     GET_SOURCE_MODE
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

LEA:
    ** DESTINATION ALWAYS ADDRESS REGISTER **
    ** GET DESTINATION An **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_LEA, A1
    BSR     PRINT_OPCODE
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    BSR     D_ADDRESS_REG_DIRECT
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

NOT:
    ** GET SIZE 1**
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_NOT, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE1
    BSR     GET_SOURCE_MODE
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

BLT:
    ** DISPLACMENT CAN BE UP TO 1 LONGWORD **
    ** GET DISPLACMENET **
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #8, D3
    BSR     GET_BITS
    MOVE.B  D1, DISPLACEMENT
    
    LEA     OPC_BLT, A1
    BSR     PRINT_OPCODE
    BSR     GET_DISPLACEMENT
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

BGE:
    ** DISPLACMENT CAN BE UP TO 1 LONGWORD **
    ** GET DISPLACMENET **
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #8, D3
    BSR     GET_BITS
    MOVE.B  D1, DISPLACEMENT
    
    LEA     OPC_BGE, A1
    BSR     PRINT_OPCODE
    BSR     GET_DISPLACEMENT
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

BEQ:
    ** DISPLACMENT CAN BE UP TO 1 LONGWORD **
    ** GET DISPLACMENET **
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #8, D3
    BSR     GET_BITS
    MOVE.B  D1, DISPLACEMENT
    
    LEA     OPC_BEQ, A1
    BSR     PRINT_OPCODE
    BSR     GET_DISPLACEMENT

    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

BRA:
    ** DISPLACMENT CAN BE UP TO 1 LONGWORD **
    ** GET DISPLACMENET **
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #8, D3
    BSR     GET_BITS
    MOVE.B  D1, DISPLACEMENT
    
    LEA     OPC_BRA, A1
    BSR     PRINT_OPCODE
    BSR     GET_DISPLACEMENT
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

DIVU:
    ** DESTINATION ALWAYS DATA REGISTER **
    ** GET DESTINATION Dn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_DIVU, A1
    BSR     PRINT_OPCODE
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    BSR     D_DATA_REGISTER
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

SUB:
    ** DESTINATION BASED ON OPMODE REGISTER **
    ** GET DESTINATION Dn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET DIRECTION **
    ** Dn - ea -> Dn (0) or ea - Dn -> ea (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 3 **
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_SUB, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE1
    BSR     GET_DIRECTION
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    

MULS:
    ** DESTINATION ALWAYS DATA REGISTER **
    ** GET DESTINATION Dn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_MULS, A1
    BSR     PRINT_OPCODE
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    BSR     D_DATA_REGISTER
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

AND:
    ** DESTINATION ALWAYS DATA REGISTER **
    ** GET DESTINATION Dn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET DIRECTION **
    ** Dn & ea -> Dn (0) or ea & Dn -> ea (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 1 **
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_AND, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE1
    BSR     GET_DIRECTION
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

ADD:
    ** DESTINATION ALWAYS DATA REGISTER **
    ** GET DESTINATION Dn **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, DESTINATION_XN
    ** GET DIRECTION **
    ** Dn + ea -> Dn (0) or ea + Dn -> ea (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 3 **
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    LEA     OPC_ADD, A1
    BSR     PRINT_OPCODE
    BSR     PRINT_SIZE1
    BSR     GET_DIRECTION
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY

LSD_IMMEDIATE:
    ** GET DIRECTION **
    ** Right (0) or Left (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    ;LEA     OPC_LSL/LSR, A1
    ;BSR     PRINT_OPCODE
    BSR     LSD_DIRECTION    
    BSR     GET_SOURCE_MODE
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    
LSD_DIRECTION:              ; GET DIRECTION FROM DIRECTION VARIABLE
    MOVE.B  (DIRECTION), D1
    CMP.B   #$0, D1
    BEQ     PRINT_LSR       ; IF 0 PRINT LSR
    CMP.B   #$1, D1
    BEQ     PRINT_LSL       ; IS 1 PRINT LSL
    
PRINT_LSR:                  ; PRINT LSR OPCODE
    LEA     OPC_LSR, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS


PRINT_LSL:                  ; PRINT LSL OPCODE
    LEA     OPC_LSL, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
LSD_REGISTER:
    ** GET COUNT/REGISTER **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, COUNT_REGISTER
    ** GET DIRECTION **
    ** Right (0) or Left (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 1 **
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET ROTATION **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, ROTATION
    ** SOURCE REGISTER ALWAYS DATA REGISTER **
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    ;LEA     OPC_LSL/LSR, A1
    ;BSR     PRINT_OPCODE
    BSR     LSD_DIRECTION 
    BSR     PRINT_SIZE1  
    BSR     REGISTER_ROTATION
    BSR     PRINT_COMMA
    BSR     S_DATA_REGISTER
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    
REGISTER_ROTATION:
    MOVE.B  (ROTATION),D1
    CMP.B   #$00,D1
    BEQ     PRINT_SHIFT_COUNT
    CMP.B   #$01,D1
    BEQ     PRINT_DATA_REGISTER
    
PRINT_SHIFT_COUNT:
    LEA     VAR_NUM, A1
    MOVE.B  #14, D0
    TRAP    #15
    
    MOVE.B  (COUNT_REGISTER),D1
    CMP.B   #$00,D1
    BEQ     PRINT_SHIFT_COUNT_EIGHT
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15
    RTS


PRINT_SHIFT_COUNT_EIGHT:
    LEA     VAR_EIGHT, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS


PRINT_DATA_REGISTER:
    MOVE.B  (COUNT_REGISTER),D1
    BRA D_DATA_REGISTER


ASD_IMMEDIATE:
    ** GET DIRECTION **
    ** Right (0) or Left (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SOURCE MODE **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_MODE
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    ;LEA     OPC_ASL/ASR, A1
    ;BSR     PRINT_OPCODE
    BSR     ASD_DIRECTION    
    BSR     GET_SOURCE_MODE
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    
ASD_DIRECTION:                  ; GET ASD DIRECTION FROM DIRECTION VARIABLE
    MOVE.B  (DIRECTION), D1
    CMP.B   #$0, D1
    BEQ     PRINT_ASR           ; IF 0 PRINT ASR
    CMP.B   #$1, D1
    BEQ     PRINT_ASL           ; IF 1 PRINT ASL
    
PRINT_ASR:                      ; PRINT ASR OPCODE
    LEA     OPC_ASR, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

PRINT_ASL:                      ; PRINT ASL OPCODE
    LEA     OPC_ASL, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS


ASD_REGISTER:
    ** GET COUNT/REGISTER **
    MOVE.W  D7, D1
    MOVE.B  #4, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, COUNT_REGISTER
    ** GET DIRECTION **
    ** Right (0) or Left (1)**
    MOVE.W  D7, D1
    MOVE.B  #7, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, DIRECTION
    ** GET SIZE 1 **
    MOVE.B  #1, SIZE_TYPE
    MOVE.W  D7, D1
    MOVE.B  #8, D2
    MOVE.B  #2, D3
    BSR     GET_BITS
    MOVE.B  D1, SIZE
    ** GET ROTATION **
    MOVE.W  D7, D1
    MOVE.B  #10, D2
    MOVE.B  #1, D3
    BSR     GET_BITS
    MOVE.B  D1, ROTATION
    ** SOURCE REGISTER ALWAYS DATA REGISTER **
    ** GET SOURCE Xn **
    MOVE.W  D7, D1
    MOVE.B  #13, D2
    MOVE.B  #3, D3
    BSR     GET_BITS
    MOVE.B  D1, SOURCE_XN
    
    ;LEA     OPC_ASL/ASR, A1
    ;BSR     PRINT_OPCODE
    BSR     ASD_DIRECTION 
    BSR     PRINT_SIZE1  
    BSR     REGISTER_ROTATION
    BSR     PRINT_COMMA
    BSR     S_DATA_REGISTER
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY
    
INVALID:
    ** PRINT INVALID INSTRUCTION **
    LEA     INSTRUCTION_ERROR, A1
    MOVE.B  #13, D0
    TRAP    #15
    BRA     CLEAR_INSTRUCTION_MEMORY

**-----------END INSTRUCTION DISASSEMBLY----------**

**---------------PRINT OPCODE---------------------**
** PRINT OPCODE LOADED IN A1
PRINT_OPCODE:
    MOVE.B  #14, D0
    TRAP    #15
    RTS

**---------------PRINT NEWLINE--------------------**
PRINT_NEWLINE:
    LEA     VAR_NEW_LINE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

**---------------PRINT COMMA----------------------**
PRINT_COMMA:
    LEA     VAR_COMMA, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

**---------------PRINT HEX----------------------**
PRINT_HEX:
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
**---------------PRINT SLASH----------------------**
PRINT_SLASH:
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS  

**---------------PRINT BASE 16--------------------**
** PRINT THE VALUE IN D1 IN BASE 16
** USED FOR PRINTING IMMEDIATE VALUES OR ADDRESSES
PRINT_BASE16:
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15
    RTS
    
**-----------GET DIRECTION FOR ADD, AND, SUB-----**
GET_DIRECTION:
    MOVE.B  (DIRECTION), D1
    CMP.B   #$00, D1
    BEQ     REGULAR_DIRECTION
    CMP.B   #$01, D1
    BEQ     FLIP_DIRECTION
    
REGULAR_DIRECTION:              ; USE MODE AS SOURCE REGISTER
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    BSR     D_DATA_REGISTER
    BSR     PRINT_NEWLINE
    BSR     CLEAR_INSTRUCTION_MEMORY

FLIP_DIRECTION:                 ; USE MODE AS DESTINATION REGISTER
    BSR     D_DATA_REGISTER
    BSR     PRINT_COMMA
    BSR     GET_SOURCE_MODE
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY    


**----------------MOVEM SUBROUTINES----------------**
** USES DIRECTION AND LIST MASK TO DETERMINE OUTPUT
** MOVEM HAS VARIABLES:
**  DIRECTION
**  SIZE 2
**  SOURCE_MODE
**  SOURCE_XN
**  REGISTER LIST MASK
MOVEM_SUBR:
    MOVE.W (A6)+, MOVEM_LIST_MASK
    MOVE.B  DIRECTION, D1
    CMP.B   #$00, D1
    BEQ     REG_TO_MEM      ; REGISTER TO MEMORY IF DIRECTION IS 0
    CMP.B   #$01, D1
    BEQ     MEM_TO_REG      ; MEMORY TO REGISTER IF DIRECTION IS 1
    BRA     INVALID

REG_TO_MEM:
    MOVE.B  SOURCE_MODE, D1
    CMP.B   #$04, D1        ; CHECK IF MODE IS PREDECREMENT
    BEQ     DA_LIST_MASK
    BRA     AD_LIST_MASK
    
MEM_TO_REG:
    BSR     GET_SOURCE_MODE
    BSR     PRINT_COMMA
    MOVE.B  SOURCE_MODE, D1
    CMP.B   #$04, D1        ; CHECK IF MODE IS PREDECREMENT
    BEQ     DA_LIST_MASK
    BSR     AD_LIST_MASK
    
    BSR     PRINT_NEWLINE
    BRA     CLEAR_INSTRUCTION_MEMORY


AD_LIST_MASK:
** LIST MASK ORDER: **
** A7 A6 A5 A4 A3 A2 A1 A0 D7 D6 D5 D4 D3 D2 D1 D0 **
    MOVE.W  (MOVEM_LIST_MASK), D5
    MOVE.W  D5, D6
    BSR     GET_LAST_REG                ; GET POSITION OF LAST REGISTER BIT AT D2
    AND.W   #%0000000000000001, D6
    CMP.W   #%0000000000000001, D6
    BEQ     MOVEM_D0        
    END_D0:                             ; RETURN TAG AFTER REGISTER PRINT         
    
    CMP.B   #$00, D4                    ; CHECK IF LAST REGISTER WAS PRINTED
    BEQ     SKIP_SLASH_0                ; IF NOT PRINTED, SKIP PRINTING SLASH
    CMP.B   #$00, D2
    BEQ     END_MASK                    ; IF LAST REGISTER, SKIP PRINTING SLASH AND END LIST MASK
    LEA     MOVEM_SLASH, A1             ; PRINT SLASH
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_0:                       ; TAG TO SKIP SLASH
    SUB.B   #1, D2                      ; DECREMENT 1 FROM LAST REGISTER POSITION COUNTER       
    MOVE.B  #$00, D4                    ; RESET REGISTER PRINTED? REGISTER

    MOVE.W  D5, D6
    AND.W   #%0000000000000010, D6
    CMP.W   #%0000000000000010, D6
    BEQ     MOVEM_D1
    END_D1:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_1
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_1:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    
    MOVE.W  D5, D6
    AND.W   #%0000000000000100, D6
    CMP.W   #%0000000000000100, D6
    BEQ     MOVEM_D2
    END_D2:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_2
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_2:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0000000000001000, D6
    CMP.W   #%0000000000001000, D6
    BEQ     MOVEM_D3
    END_D3:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_3
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_3:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0000000000010000, D6
    CMP.W   #%0000000000010000, D6
    BEQ     MOVEM_D4
    END_D4:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_4
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_4:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000000100000, D6
    CMP.W   #%0000000000100000, D6
    BEQ     MOVEM_D5
    END_D5:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_5
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_5:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000001000000, D6
    CMP.W   #%0000000001000000, D6
    BEQ     MOVEM_D6
    END_D6:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_6
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_6:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6    
    AND.W   #%0000000010000000, D6
    CMP.W   #%0000000010000000, D6
    BEQ     MOVEM_D7
    END_D7:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_7
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_7:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000100000000, D6
    CMP.W   #%0000000100000000, D6
    BEQ     MOVEM_A0        
    END_A0:                 
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_8    
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_8: 
    SUB.B   #1, D2           
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000001000000000, D6
    CMP.W   #%0000001000000000, D6
    BEQ     MOVEM_A1
    END_A1:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_9
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_9:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000010000000000, D6
    CMP.W   #%0000010000000000, D6
    BEQ     MOVEM_A2
    END_A2:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_10
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_10:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000100000000000, D6
    CMP.W   #%0000100000000000, D6
    BEQ     MOVEM_A3
    END_A3:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_11
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_11:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0001000000000000, D6
    CMP.W   #%0001000000000000, D6
    BEQ     MOVEM_A4
    END_A4:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_12
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_12:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0010000000000000, D6
    CMP.W   #%0010000000000000, D6
    BEQ     MOVEM_A5
    END_A5:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_13
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_13:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0100000000000000, D6
    CMP.W   #%0100000000000000, D6
    BEQ     MOVEM_A6
    END_A6:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_14
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_14:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6    
    AND.W   #%1000000000000000, D6
    CMP.W   #%1000000000000000, D6
    BEQ     MOVEM_A7
    END_A7:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_15
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_15:
    END_MASK:
    RTS



DA_LIST_MASK:   ; PREDECREMENT MODE
** LIST MASK ORDER: **
** D0 D1 D2 D3 D4 D5 D6 D7 A0 A1 A2 A3 A4 A5 A6 A7 * *
    MOVE.W  (MOVEM_LIST_MASK), D5
    MOVE.W  D5, D6
    BSR     GET_LAST_REG                ; RETURNS POSITION OF LAST REGISTER BIT AT D2
    AND.W   #%0000000000000001, D6
    CMP.W   #%0000000000000001, D6
    BEQ     MOVEM_A7_DA        
    END_A7_DA:                 
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_0_DA   
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_0_DA:
    SUB.B   #1, D2           
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000000000010, D6
    CMP.W   #%0000000000000010, D6
    BEQ     MOVEM_A6_DA
    END_A6_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_1_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_1_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    
    MOVE.W  D5, D6
    AND.W   #%0000000000000100, D6
    CMP.W   #%0000000000000100, D6
    BEQ     MOVEM_A5_DA
    END_A5_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_2_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_2_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0000000000001000, D6
    CMP.W   #%0000000000001000, D6
    BEQ     MOVEM_A4_DA
    END_A4_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_3_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_3_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0000000000010000, D6
    CMP.W   #%0000000000010000, D6
    BEQ     MOVEM_A3_DA
    END_A3_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_4_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_4_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000000100000, D6
    CMP.W   #%0000000000100000, D6
    BEQ     MOVEM_A2_DA
    END_A2_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_5_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_5_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000001000000, D6
    CMP.W   #%0000000001000000, D6
    BEQ     MOVEM_A1_DA
    END_A1_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_6_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_6_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6    
    AND.W   #%0000000010000000, D6
    CMP.W   #%0000000010000000, D6
    BEQ     MOVEM_A0_DA
    END_A0_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_7_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_7_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000000100000000, D6
    CMP.W   #%0000000100000000, D6
    BEQ     MOVEM_D7_DA       
    END_D7_DA:                 
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_8_DA   
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_8_DA: 
    SUB.B   #1, D2           
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000001000000000, D6
    CMP.W   #%0000001000000000, D6
    BEQ     MOVEM_D6_DA
    END_D6_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_9_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_9_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000010000000000, D6
    CMP.W   #%0000010000000000, D6
    BEQ     MOVEM_D5_DA
    END_D5_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_10_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_10_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0000100000000000, D6
    CMP.W   #%0000100000000000, D6
    BEQ     MOVEM_D4_DA
    END_D4_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_11_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_11_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4
    
    MOVE.W  D5, D6
    AND.W   #%0001000000000000, D6
    CMP.W   #%0001000000000000, D6
    BEQ     MOVEM_D3_DA
    END_D3_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_12_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_12_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6
    AND.W   #%0010000000000000, D6
    CMP.W   #%0010000000000000, D6
    BEQ     MOVEM_D2_DA
    END_D2_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_13_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_13_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D1

    MOVE.W  D5, D6
    AND.W   #%0100000000000000, D6
    CMP.W   #%0100000000000000, D6
    BEQ     MOVEM_D1_DA
    END_D1_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_14_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_14_DA:
    SUB.B   #1, D2 
    MOVE.B  #$00, D4

    MOVE.W  D5, D6    
    AND.W   #%1000000000000000, D6
    CMP.W   #%1000000000000000, D6
    BEQ     MOVEM_D0_DA
    END_D0_DA:
    
    CMP.B   #$00, D4
    BEQ     SKIP_SLASH_15_DA
    CMP.B   #$00, D2
    BEQ     END_MASK
    LEA     MOVEM_SLASH, A1
    MOVE.B  #14, D0
    TRAP    #15
    SKIP_SLASH_15_DA:
    END_MASK_DA:
    RTS

; RETURN POSITION OF LAST REGISTER TO BE PRINTED IN LIST MASK
GET_LAST_REG:
    MOVE.B  #16, D2         ; START COUNTER AT 16
    MOVE.W  D5, D3          ; MOVE LIST MASK INTO D3
    REG_START:              ; TAG TO CONTINUE LOOP
    CMP.W   #$0000, D3      ; CHECK IS LIST MASK 0
    BEQ     INVALID         ; IF LIST MASK IS 0; LIST MASK IS INVALID
    SUB.B   #1, D2          ; SUBTRACT 1 FROM COUNTER
    LSL.W   #1, D3          ; LEFT SHIFT 1 BIT OUT OF MASK
    BCS     CARRY_SET       ; IF 1 SHIFTED OUT, LAST REGISTER FOUND, CARRY IS SET
    BRA     REG_START       ; IF 0 SHIFTED OUT, RESTART LOOP
    * BRANCH IS 1 SHIFTED OUT FRONT
    * RETURNS POSITION OF LAST REGISTER IN D2
    CARRY_SET:              ; RTS ONCE LAST REGISTER FOUND
    RTS

; PRINT D0 REGISTER
MOVEM_D0:
    LEA     DATA_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15 
    MOVE.B  #1, D4
    BRA     END_D0

; PRINT D1 REGISTER
MOVEM_D1:
    LEA     DATA_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D1
    
; PRINT D2 REGISTER
MOVEM_D2:
    LEA     DATA_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D2 

; PRINT D3 REGISTER    
MOVEM_D3:
    LEA     DATA_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D3

; PRINT D4 REGISTER
MOVEM_D4:
    LEA     DATA_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D4
    
; PRINT D5 REGISTER
MOVEM_D5:
    LEA     DATA_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D5
    
; PRINT D6 REGISTER
MOVEM_D6:
    LEA     DATA_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D6
    
; PRINT D7 REGISTER
MOVEM_D7:
    LEA     DATA_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D7
    
; PRINT A0 REGISTER
MOVEM_A0:
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15 
    MOVE.B  #1, D4
    BRA     END_A0
    
; PRINT A1 REGISTER
MOVEM_A1:
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A1
    
; PRINT A2 REGISTER
MOVEM_A2:
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A2 
    
; PRINT A3 REGISTER
MOVEM_A3:
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A3

; PRINT A4 REGISTER
MOVEM_A4:
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A4
    
; PRINT A5 REGISTER
MOVEM_A5:
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A5
    
; PRINT A6 REGISTER
MOVEM_A6:
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A6
    
; PRINT A7 REGISTER
MOVEM_A7:
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A7


** PREDECREMENT MODE PRINT FUNCTIONS BELOW **
; PRINT D0 REGISTER
MOVEM_D0_DA:
    LEA     DATA_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15 
    MOVE.B  #1, D4
    BRA     END_D0_DA
    
; PRINT D1 REGISTER
MOVEM_D1_DA:
    LEA     DATA_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D1_DA
    
; PRINT D2 REGISTER
MOVEM_D2_DA:
    LEA     DATA_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D2_DA 
    
; PRINT D3 REGISTER
MOVEM_D3_DA:
    LEA     DATA_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D3_DA

; PRINT D4 REGISTER
MOVEM_D4_DA:
    LEA     DATA_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D4_DA
    
; PRINT D5 REGISTER
MOVEM_D5_DA:
    LEA     DATA_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D5_DA
    
; PRINT D6 REGISTER
MOVEM_D6_DA:
    LEA     DATA_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D6_DA
    
; PRINT D7 REGISTER
MOVEM_D7_DA:
    LEA     DATA_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_D7_DA
    
; PRINT A0 REGISTER
MOVEM_A0_DA:
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15 
    MOVE.B  #1, D4
    BRA     END_A0_DA
    
; PRINT A1 REGISTER
MOVEM_A1_DA:
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A1_DA
    
; PRINT A2 REGISTER
MOVEM_A2_DA:
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A2_DA 
    
; PRINT A3 REGISTER
MOVEM_A3_DA:
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A3_DA

; PRINT A4 REGISTER
MOVEM_A4_DA:
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A4_DA
    
; PRINT A5 REGISTER
MOVEM_A5_DA:
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A5_DA
    
; PRINT A6 REGISTER
MOVEM_A6_DA:
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A6_DA
    
; PRINT A7 REGISTER
MOVEM_A7_DA:
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  #1, D4
    BRA     END_A7_DA

    
**---------------GET BCC DISPLACEMENT--------------------**

GET_DISPLACEMENT:               ; GET SIZE OF DISPLACEMENT
    MOVE.B  (DISPLACEMENT), D1
    CMP.B   #$00, D1
    BEQ     PRINT_WORD_DISPLACEMENT
    CMP.B   #$FF, D1
    BEQ     PRINT_LONG_DISPLACEMENT
    BRA     PRINT_BYTE_DISPLACEMENT

PRINT_BYTE_DISPLACEMENT:        ; PRINT BYTE DISPLACEMENT FROM OPCODE
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.B  (DISPLACEMENT), D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT IN BASE 16
    RTS
    
PRINT_WORD_DISPLACEMENT:        ; GET WORD DISPLACEMENT FROM MEMORY, PRINT WORD
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.W (A6)+,D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT IN BASE 16
    RTS
    
PRINT_LONG_DISPLACEMENT:        ; GET LONG DISPLACEMENT FROM MEMORY, PRINT LONG
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15
    MOVE.L (A6)+,D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2             ; PRINT IN BASE 16
    TRAP    #15 
    RTS

**-------------------GET MODE---------------------**
** ARGUMENTS:
* D1: SOURCE MODE
*   D1: MODE OF SOURCE REGISTER
GET_SOURCE_MODE:
    MOVE.B  SOURCE_MODE, D1
    CMP.B   #$00, D1
    BEQ     S_DATA_REGISTER             ; IF MODE = %000 XN IS DATA REGISTER
    CMP.B   #$01, D1
    BEQ     S_ADDRESS_REG_DIRECT        ; IF MODE = %001 XN IS ADDRESS REG DIRECT
    CMP.B   #$02, D1
    BEQ     S_ADDRESS_REG_INDIRECT      ; IF MODE = %002 XN IS ADDRESS REG INDIRECT 
    CMP.B   #$03, D1
    BEQ     S_ADDRESS_REG_POSTINC       ; IF MODE = %003 XN IS ADDRESS REG WITH POSTINCREMENT
    CMP.B   #$04, D1
    BEQ     S_ADDRESS_REG_PREDEC        ; IF MODE = %004 XN IS ADDRESS REG WITH PREDECREMENT
    CMP.B   #$07, D1                    ; IF MODE = %111 XN IS NEEDED TO DETERMINE 
    BEQ     S_IMM_ABS_WORD_LONG       ; NEED Xn TO DETERMINE
    BRA     INVALID

S_DATA_REGISTER:            ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  SOURCE_XN, D1               ; GET SOURCE_XN FROM MEMORY
    CMP.B   #$00, D1                    ; DETERMINE WHAT DATA REGISTER 
    BEQ     PRINT_D0                    ; PRINT CORRESPONDING REGISTER
    CMP.B   #$01, D1
    BEQ     PRINT_D1
    CMP.B   #$02, D1
    BEQ     PRINT_D2
    CMP.B   #$03, D1
    BEQ     PRINT_D3
    CMP.B   #$04, D1
    BEQ     PRINT_D4
    CMP.B   #$05, D1
    BEQ     PRINT_D5
    CMP.B   #$06, D1
    BEQ     PRINT_D6
    CMP.B   #$07, D1
    BEQ     PRINT_D7
    BRA     INVALID
    
S_ADDRESS_REG_DIRECT:           ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  SOURCE_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0
    CMP.B   #$01, D1
    BEQ     PRINT_A1
    CMP.B   #$02, D1
    BEQ     PRINT_A2
    CMP.B   #$03, D1
    BEQ     PRINT_A3
    CMP.B   #$04, D1
    BEQ     PRINT_A4
    CMP.B   #$05, D1
    BEQ     PRINT_A5
    CMP.B   #$06, D1
    BEQ     PRINT_A6
    CMP.B   #$07, D1
    BEQ     PRINT_A7
    BRA     INVALID
    
S_ADDRESS_REG_INDIRECT:         ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  SOURCE_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_IND
    CMP.B   #$01, D1
    BEQ     PRINT_A1_IND
    CMP.B   #$02, D1
    BEQ     PRINT_A2_IND
    CMP.B   #$03, D1
    BEQ     PRINT_A3_IND
    CMP.B   #$04, D1
    BEQ     PRINT_A4_IND
    CMP.B   #$05, D1
    BEQ     PRINT_A5_IND
    CMP.B   #$06, D1
    BEQ     PRINT_A6_IND
    CMP.B   #$07, D1
    BEQ     PRINT_A7_IND
    BRA     INVALID
    
S_ADDRESS_REG_POSTINC:          ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  SOURCE_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_POSTINC
    CMP.B   #$01, D1
    BEQ     PRINT_A1_POSTINC
    CMP.B   #$02, D1
    BEQ     PRINT_A2_POSTINC
    CMP.B   #$03, D1
    BEQ     PRINT_A3_POSTINC
    CMP.B   #$04, D1
    BEQ     PRINT_A4_POSTINC
    CMP.B   #$05, D1
    BEQ     PRINT_A5_POSTINC
    CMP.B   #$06, D1
    BEQ     PRINT_A6_POSTINC
    CMP.B   #$07, D1
    BEQ     PRINT_A7_POSTINC
    BRA     INVALID

S_ADDRESS_REG_PREDEC:           ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  SOURCE_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_PREDEC
    CMP.B   #$01, D1
    BEQ     PRINT_A1_PREDEC
    CMP.B   #$02, D1
    BEQ     PRINT_A2_PREDEC
    CMP.B   #$03, D1
    BEQ     PRINT_A3_PREDEC
    CMP.B   #$04, D1
    BEQ     PRINT_A4_PREDEC
    CMP.B   #$05, D1
    BEQ     PRINT_A5_PREDEC
    CMP.B   #$06, D1
    BEQ     PRINT_A6_PREDEC
    CMP.B   #$07, D1
    BEQ     PRINT_A7_PREDEC
    BRA     INVALID
    
S_IMM_ABS_WORD_LONG:
    ** GET XN VALUE TO DERETMINE IF IMMEDIATE, ABSOLUTE LONG OR ABSOLUTE WORD **
    MOVE.B  SOURCE_XN, D1
    CMP.B   #$04, D1
    BEQ     SOURCE_IMMEDIATE
    CMP.B   #$01, D1
    BEQ     SOURCE_ABS_LONG
    CMP.B   #$00, D1
    BEQ     SOURCE_ABS_WORD
    BRA     INVALID

SOURCE_IMMEDIATE:
    ** USE SIZE TO DETERMINE SIZE OF IMMEDIATE DATA **
    MOVE.B  SIZE_TYPE, D1
    CMP.B   #$01, D1
    BEQ     S_IMMEDIATE_SIZE1
    CMP.B   #$02, D1
    BEQ     S_IMMEDIATE_SIZE2
    CMP.B   #$03, D1
    BEQ     S_IMMEDIATE_SIZE3
    BRA     IMMEDIATE_WORD
   
S_IMMEDIATE_SIZE1:          ; USE SIZE TO DETERMINE IF BYTE, WORD, OR LONG
    MOVE.B  SIZE, D1
    CMP.B   #$00, D1
    BEQ     IMMEDIATE_BYTE
    CMP.B   #$01, D1
    BEQ     IMMEDIATE_WORD
    CMP.B   #$02, D1
    BEQ     IMMEDIATE_LONG
    BRA     INVALID

S_IMMEDIATE_SIZE2:          ; USE SIZE TO DETERMINE IF WORD OR LONG
    MOVE.B  SIZE, D1
    CMP.B   #$00, D1
    BEQ     IMMEDIATE_WORD
    CMP.B   #$01, D1
    BEQ     IMMEDIATE_LONG
    BRA     INVALID

S_IMMEDIATE_SIZE3:          ; USE SIZE TO DETERMINE IF BYTE, WORD, OR LONG
    MOVE.B  SIZE, D1
    CMP.B   #$01, D1
    BEQ     IMMEDIATE_BYTE
    CMP.B   #$03, D1
    BEQ     IMMEDIATE_WORD
    CMP.B   #$02, D1
    BEQ     IMMEDIATE_LONG
    BRA     INVALID

IMMEDIATE_BYTE:             ; PRINT IMMEDIATE WORD IF IMMEDIATE BYTE USED
    MOVE.L  #$00000000, D1
    LEA     VAR_NUM, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "#"
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "$"
    MOVE.W  (A6)+, D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15             ; PRINT WORD VALUE
    RTS

IMMEDIATE_WORD:             ; PRINT IMMEDIATE WORD VALUE
    MOVE.L  #$0000000, D1
    LEA     VAR_NUM, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "#"
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "$"
    MOVE.W  (A6)+, D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15
    RTS

IMMEDIATE_LONG:             ; PRINT IMMEDIATE LONG VALUE
    LEA     VAR_NUM, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "#"
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15             ; PRINT "$"
    MOVE.L  (A6)+, D1
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15
    RTS

SOURCE_ABS_LONG:            ; PRINT ABSOLUTE LONG VALUE
    MOVE.L  #$00000000, D1      ; CLEAR D1
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15                 ; PRINT HEX SIGN
    MOVE.L  (A6)+, D1           ; DEREFERENCE NEXT MEMORY ADDRESS
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT VALUE IN HEX
    RTS
    
SOURCE_ABS_WORD:            ; PRINT ABSOLUTE WORD VALUE
    MOVE.L  #$00000000, D1      ; CLEAR D1
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15                 ; PRINT HEX SIGN
    MOVE.W  (A6)+, D1           ; DEREFERENCE NEXT MEMORY ADDRESS
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT VALUE IN HEX
    RTS
    
**-------------------GET MODE---------------------**
** ARGUMENTS:
* D1: SOURCE MODE
*   D1: MODE OF SOURCE REGISTER
GET_DEST_MODE:
    MOVE.B  DESTINATION_MODE, D1
    CMP.B   #$00, D1
    BEQ     D_DATA_REGISTER
    CMP.B   #$01, D1
    BEQ     D_ADDRESS_REG_DIRECT
    CMP.B   #$02, D1
    BEQ     D_ADDRESS_REG_INDIRECT
    CMP.B   #$03, D1
    BEQ     D_ADDRESS_REG_POSTINC
    CMP.B   #$04, D1
    BEQ     D_ADDRESS_REG_PREDEC
    CMP.B   #$07, D1
    BEQ     D_IMM_ABS_WORD_LONG       ; NEED Xn TO DETERMINE
    BRA     INVALID

D_DATA_REGISTER:            ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_D0
    CMP.B   #$01, D1
    BEQ     PRINT_D1
    CMP.B   #$02, D1
    BEQ     PRINT_D2
    CMP.B   #$03, D1
    BEQ     PRINT_D3
    CMP.B   #$04, D1
    BEQ     PRINT_D4
    CMP.B   #$05, D1
    BEQ     PRINT_D5
    CMP.B   #$06, D1
    BEQ     PRINT_D6
    CMP.B   #$07, D1
    BEQ     PRINT_D7
    BRA     INVALID

D_ADDRESS_REG_DIRECT:           ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0
    CMP.B   #$01, D1
    BEQ     PRINT_A1
    CMP.B   #$02, D1
    BEQ     PRINT_A2
    CMP.B   #$03, D1
    BEQ     PRINT_A3
    CMP.B   #$04, D1
    BEQ     PRINT_A4
    CMP.B   #$05, D1
    BEQ     PRINT_A5
    CMP.B   #$06, D1
    BEQ     PRINT_A6
    CMP.B   #$07, D1
    BEQ     PRINT_A7
    BRA     INVALID
    
D_ADDRESS_REG_INDIRECT:         ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_IND
    CMP.B   #$01, D1
    BEQ     PRINT_A1_IND
    CMP.B   #$02, D1
    BEQ     PRINT_A2_IND
    CMP.B   #$03, D1
    BEQ     PRINT_A3_IND
    CMP.B   #$04, D1
    BEQ     PRINT_A4_IND
    CMP.B   #$05, D1
    BEQ     PRINT_A5_IND
    CMP.B   #$06, D1
    BEQ     PRINT_A6_IND
    CMP.B   #$07, D1
    BEQ     PRINT_A7_IND
    BRA     INVALID
    
D_ADDRESS_REG_POSTINC:          ; DETERMINE WHICH REGISTER TO BE PRINTED
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_POSTINC
    CMP.B   #$01, D1
    BEQ     PRINT_A1_POSTINC
    CMP.B   #$02, D1
    BEQ     PRINT_A2_POSTINC
    CMP.B   #$03, D1
    BEQ     PRINT_A3_POSTINC
    CMP.B   #$04, D1
    BEQ     PRINT_A4_POSTINC
    CMP.B   #$05, D1
    BEQ     PRINT_A5_POSTINC
    CMP.B   #$06, D1
    BEQ     PRINT_A6_POSTINC
    CMP.B   #$07, D1
    BEQ     PRINT_A7_POSTINC
    BRA     INVALID
    
D_ADDRESS_REG_PREDEC:           ; DETERMINE WHICH DATA REGISTER TO BE PRINTED
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$00, D1
    BEQ     PRINT_A0_PREDEC
    CMP.B   #$01, D1
    BEQ     PRINT_A1_PREDEC
    CMP.B   #$02, D1
    BEQ     PRINT_A2_PREDEC
    CMP.B   #$03, D1
    BEQ     PRINT_A3_PREDEC
    CMP.B   #$04, D1
    BEQ     PRINT_A4_PREDEC
    CMP.B   #$05, D1
    BEQ     PRINT_A5_PREDEC
    CMP.B   #$06, D1
    BEQ     PRINT_A6_PREDEC
    CMP.B   #$07, D1
    BEQ     PRINT_A7_PREDEC
    BRA     INVALID
    
D_IMM_ABS_WORD_LONG:
    ** GET XN VALUE TO DERETMINE IF IMMEDIATE, ABSOLUTE LONG OR ABSOLUTE WORD **
    MOVE.B  DESTINATION_XN, D1
    CMP.B   #$04, D1
    BEQ     DEST_IMMEDIATE
    CMP.B   #$01, D1
    BEQ     DEST_ABS_LONG
    CMP.B   #$00, D1
    BEQ     DEST_ABS_WORD
    BRA     INVALID

DEST_IMMEDIATE:
    ** DESTINATION CANNOT BE IMMEDIATE DATA **
    BRA INVALID
    
DEST_ABS_LONG:          ; PRINT ABSOLUTE LONG VALUE
    MOVE.L  #$00000000, D1      ; CLEAR D1
    MOVE.B  #14, D0
    TRAP    #15                 ; PRINT HEX SIGN
    MOVE.L  (A6)+, D1           ; DEREFERENCE NEXT LONG IN MEMORY
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT VALUE
    RTS
    
DEST_ABS_WORD:          ; PRINT ABSOLUTE WORD VALUE
    MOVE.L  #$00000000, D1      ; CLEAR D1
    LEA     VAR_HEX, A1
    MOVE.B  #14, D0
    TRAP    #15                 ; PRINT HEX SIGN
    MOVE.W  (A6)+, D1           ; DEREFERENCE NEXT WORD IN MEMORY
    MOVE.B  #15, D0
    MOVE.B  #16, D2
    TRAP    #15                 ; PRINT VALUE IN HEX
    RTS
    
**----------------PRINT DATA REGISTER-------------**
PRINT_D0:
    LEA     DATA_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D1:
    LEA     DATA_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D2:
    LEA     DATA_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D3:
    LEA     DATA_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D4:
    LEA     DATA_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D5:
    LEA     DATA_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D6:
    LEA     DATA_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_D7:
    LEA     DATA_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
**----------------PRINT ADDRESS REGISTER-------------**
PRINT_A0:
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A1:
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A2:
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A3:
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A4:
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A5:
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A6:
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A7:
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
*----------------PRINT ADDRESS REGISTER INDIRECT-------------**
PRINT_A0_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A1_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A2_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A3_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A4_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A5_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A6_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A7_IND:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

*----------------PRINT ADDRESS REGISTER POSTINCREMENT-------------**
PRINT_A0_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A1_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A2_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A3_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A4_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A5_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A6_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A7_POSTINC:
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_PLUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

*----------------PRINT ADDRESS REGISTER PREDECREMENT-------------**
PRINT_A0_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ZERO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A1_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_ONE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A2_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_TWO, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A3_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_THREE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A4_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FOUR, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A5_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_FIVE, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A6_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SIX, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_A7_PREDEC:
    LEA     VAR_MINUS, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_OPEN_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     ADDR_SEVEN, A1
    MOVE.B  #14, D0
    TRAP    #15
    LEA     VAR_CLOSE_PAREN, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

**-------------------GET SIZE---------------------**
** USES SIZE IN SIZE MEMORY LOCATION**
PRINT_SIZE1:        ; DETERMINE SIZE FROM SIZE 1 
    MOVE.B  SIZE, D1
    CMP.B   #$00, D1
    BEQ     PRINT_BYTE
    CMP.B   #$01, D1
    BEQ     PRINT_WORD
    CMP.B   #$02, D1
    BEQ     PRINT_LONG
    BRA     INVALID
    
PRINT_SIZE2:        ; DETERMINE SIZE FROM SIZE 2
    MOVE.B  SIZE, D1
    CMP.B   #$00, D1
    BEQ     PRINT_WORD
    CMP.B   #$01, D1
    BEQ     PRINT_LONG
    BRA     INVALID
    
    
PRINT_SIZE3:        ; DETERMINE SIZE FROM SIZE 3
    MOVE.B  SIZE, D1
    CMP.B   #$01, D1
    BEQ     PRINT_BYTE
    CMP.B   #$03, D1
    BEQ     PRINT_WORD
    CMP.B   #$02, D1
    BEQ     PRINT_LONG
    BRA     INVALID

PRINT_BYTE:         ; PRINT .B OPCODE ENDING
    LEA     VAR_BYTE, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS
    
PRINT_WORD:         ; PRINT .W OPCODE ENDING
    LEA     VAR_WORD, A1
    MOVE.B  #14, D0
    TRAP    #15
    RTS

PRINT_LONG:         ; PRINT .L OPCODE ENDING
    LEA     VAR_LONG, A1
    MOVE.B  #14, D0
    TRAP    #15    
    RTS
   
**------------------VARIABLES---------------------**
LF  EQU  $0A                        ; Line Feed
CR  EQU  $0D                        ; Carriage Return 
**----------DISPLAY INSTRUCTION CONSTANTS---------**
OPC_NOP                    DC.L        'NOP ',0      * Required OP CODE
OPC_MOVE                   DC.L        'MOVE',0     * Required OP CODE   
OPC_MOVEM                  DC.L        'MOVEM',0    * Required OP CODE
OPC_ADD                    DC.L        'ADD',0      * Required OP CODE
OPC_SUB                    DC.L        'SUB',0      * Required OP CODE
OPC_MULS                   DC.L        'MULS ',0     * Required OP CODE
OPC_DIVU                   DC.L        'DIVU ',0     * Required OP CODE
OPC_LEA                    DC.L        'LEA ',0      * Required OP CODE
OPC_AND                    DC.L        'AND',0      * Required OP CODE
OPC_NOT                    DC.L        'NOT',0      * Required OP CODE
OPC_LSL                    DC.L        'LSL',0      * Required OP CODE
OPC_LSR                    DC.L        'LSR',0      * Required OP CODE
OPC_ASR                    DC.L        'ASR',0      * Required OP CODE
OPC_ASL                    DC.L        'ASL',0      * Required OP CODE
OPC_BLT                    DC.L        'BLT ',0     * Required OP CODE
OPC_BGE                    DC.L        'BGE ',0     * Required OP CODE
OPC_BEQ                    DC.L        'BEQ ',0     * Required OP CODE
OPC_JSR                    DC.L        'JSR ',0     * Required OP CODE
OPC_RTS                    DC.L        'RTS',0      * Required OP CODE
OPC_BRA                    DC.L        'BRA ',0     * Required OP CODE

VAR_ZERO                   DC.L        '0',0		* Symbol for printing OP code
VAR_ONE                    DC.L        '1',0		* Symbol for printing OP code
VAR_TWO                    DC.L        '2',0	    * Symbol for printing OP code
VAR_THREE                  DC.L        '3',0        * Symbol for printing OP code
VAR_FOUR                   DC.L        '4',0        * Symbol for printing OP code
VAR_FIVE                   DC.L        '5',0        * Symbol for printing OP code
VAR_SIX                    DC.L        '6',0        * Symbol for printing OP code
VAR_SEVEN                  DC.L        '7',0		* Symbol for printing OP code
VAR_EIGHT                  DC.L        '8',0        * Symbol for printing OP code
VAR_NINE                   DC.L        '9',0   	    * Symbol for printing OP code
VAR_A                      DC.L        'A',0        * Symbol for printing OP code
VAR_B                      DC.L        'B',0	    * Symbol for printing OP code
VAR_C                      DC.L        'C',0		* Symbol for printing OP code
VAR_D                      DC.L        'D',0        * Symbol for printing OP code
VAR_E                      DC.L        'E',0   	    * Symbol for printing OP code
VAR_F                      DC.L        'F',0		* Symbol for printing OP code

VAR_LONG                   DC.L        '.L ',0		* Symbol for printing OP code
VAR_WORD                   DC.L        '.W ',0		* Symbol for printing OP code
VAR_BYTE                   DC.L        '.B ',0		* Symbol for printing OP code

VAR_BINARY                 DC.L        '%',0		* Symbol used for formatting
VAR_HEX                    DC.L        '$',0		* Symbol used for formatting
VAR_NUM                    DC.L        '#',0		* Symbol used for formatting

VAR_OPEN_PAREN        	   DC.L        '(',0		* Symbol used for formatting
VAR_CLOSE_PAREN            DC.L        ')',0		* Symbol used for formatting
MOVEM_SLASH                DC.L        '/',0		* Symbol used for formatting
VAR_PLUS               	   DC.L        '+',0		* Symbol used for formatting
VAR_MINUS              	   DC.L        '-',0		* Symbol used for formatting
VAR_COMMA                  DC.L        ',',0		* Symbol used for formatting
VAR_SPACE                  DC.L        ' ',0		* Symbol used for formatting
VAR_TAB                    DC.L        '    ',0     * Symbol used for formatting
VAR_NEW_LINE               DC.B        '',CR,LF,0   * Symbol used for formatting
VAR_DATA_REG           	   DC.L        'D',0		* Symbol used for formatting
VAR_ADDR_REG        	   DC.L        'A',0		* Symbol used for formatting
VAR_COM                    DC.L        ',',0        * Symbol used for formatting
VAR_DATA                   DC.B        'DATA    ',0	* For Data Errors

ADDR_SEVEN                 DC.L        'A7',0
ADDR_SIX                   DC.L        'A6',0
ADDR_FIVE                  DC.L        'A5',0
ADDR_FOUR                  DC.L        'A4',0
ADDR_THREE                 DC.L        'A3',0
ADDR_TWO                   DC.L        'A2',0
ADDR_ONE                   DC.L        'A1',0
ADDR_ZERO                  DC.L        'A0',0

DATA_SEVEN                 DC.L        'D7',0
DATA_SIX                   DC.L        'D6',0
DATA_FIVE                  DC.L        'D5',0
DATA_FOUR                  DC.L        'D4',0
DATA_THREE                 DC.L        'D3',0
DATA_TWO                   DC.L        'D2',0
DATA_ONE                   DC.L        'D1',0
DATA_ZERO                  DC.L        'D0',0

INSTRUCTION_PROMPT  DC.B    'ENTER HEX INSTRUCTION: ',0
ERROR               DC.B    'INPUT ERROR',CR,LF,0
INSTRUCTION_ERROR   DC.B    'INVALID INSTRUCTION',CR,LF,0
GET_START_ADDRESS   DC.B    'ENTER START ADDRESS IN LONG HEX FORMAT: ',0
GET_END_ADDRESS     DC.B    'ENTER END ADDRESS IN LONG HEX FORMAT: ',0
TEST_FAIL           DC.B    'ASSERT FAILED: ',0           
TEST_SUCC           DC.B    'ASSERT SUCCESSFUL: ',0

**-------------------MEMORY FOR OPCODE DECOMPOSITION----------------**
FIRST_FOUR_NYBBLE   DS.B    1       ; DECLARE 1 BYTE FOR FIRST NYBBLE
DESTINATION_MODE    DS.B    1       ; DECLARE 1 BYTE FOR DESTINATION MODE
DESTINATION_XN      DS.B    1       ; DECLARE 1 BYTE FOR DESTINATION Xn
SOURCE_MODE         DS.B    1       ; DECLARE 1 BYTE FOR SOURCE MODE
SOURCE_XN           DS.B    1       ; DELCARE 1 BYTE FOR SOURCE Xn
SIZE                DS.B    1       ; DECLARE 1 BYTE FOR SIZE
SIZE_TYPE           DS.B    1       ; DECLARE 1 BYTE FOR TYPE OF SIZE (1,2,3)
DIRECTION           DS.B    1       ; DECLARE 1 BYTE FOR DIRECTION
ROTATION            DS.B    1       ; DECLARE 1 BYTE FOR LSD/ASD ROTATION
COUNT_REGISTER      DS.B    1       ; DECLARE 1 BYTE FOR LSD/ASD COUNT/REGISTER
DISPLACEMENT        DS.B    1       ; DECLARE UP TO 1 LONGWORD FOR BCC DISPLACEMENT
MOVEM_LIST_MASK     DS.W    1       ; DECLARE 1 WORD FOR MOVEM LIST MASK    
INSTRUCTION_LENGTH  DS.W    1       ; DECLARE 1 BYTE FOR LENGTH
ASCII_INSTRUCTION   DS.W    10      ; DECLARE UP TO 10 WORDS FOR ASCII INSTRUCTION
INSTRUCTION_BREAK   DS.B    1       ; BREAK ASCII INSTRUCTION AND HEX INSTRUCTION IN MEMORY
INSTRUCTION         DS.W    5       ; DECLARE UP TO 5 WORDS FOR HEX INSTRUCTION
START_ADDRESS       DS.L    1       ; DECLARE START ADDRESS
END_ADDRESS         DS.L    1       ; DECLARE END ADDRESS

TEST_VAR_1          DS.L    1       ; FOR TESTING          
TEST_VAR_2          DS.L    1       ; FOR TESTING
    END    START        


















*~Font name~Courier New~
*~Font size~12~
*~Tab type~1~
*~Tab size~4~
